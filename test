-- Colony Integrator on TOP, ME Bridge on BOTTOM, Chest/Barrel on RIGHT
local colony = peripheral.wrap("top")
if not colony then error("No Colony Integrator detected on TOP") end

local me = peripheral.wrap("bottom")
if not me then error("No ME Bridge detected on BOTTOM") end

local TARGET_SIDE = "right"

local function log(msg) print(os.date("%H:%M:%S") .. " | " .. msg) end

-- ====== CONFIG: add builder hut locations here ======
local BUILDERS = {
  -- { x = 0, y = 0, z = 0, dimension = "minecraft:overworld" },
}
-- ================================================

-- Netherite tool whitelist
local netheriteTools = {
  ["minecraft:netherite_pickaxe"] = true,
  ["minecraft:netherite_axe"] = true,
  ["minecraft:netherite_shovel"] = true,
  ["minecraft:netherite_hoe"] = true,
  ["minecraft:netherite_sword"] = true
}
local function isNetheriteTool(id) return netheriteTools[id] == true end

-- Safe ME call wrapper
local function meSafe(name, arg1, arg2)
  local ok, res = pcall(function() return me[name](arg1, arg2) end)
  if not ok then
    log("‚ö† ME." .. name .. " error: " .. tostring(res))
    return nil
  end
  return res
end

-- AE2 helpers
local function getItemCount(id)
  local items = meSafe("getItems") or {}
  local total = 0
  for _, it in pairs(items) do
    if it and it.name == id then total = total + (it.count or 0) end
  end
  return total
end

local function isCraftable(id)
  local res = meSafe("isCraftable", { name = id })
  return res == true
end

-- Craft throttling
local MIN_CRAFT_DELAY = 1.0
local MAX_CRAFTS_PER_LOOP = 6
local lastCraftTime = 0
local craftsThisLoop = 0

local function requestCraft(id, count)
  if count <= 0 then return true end
  if craftsThisLoop >= MAX_CRAFTS_PER_LOOP then
    log("‚è∏ Craft cap reached this loop, skipping: " .. id .. " x" .. count)
    return false
  end
  if not isCraftable(id) then
    log("‚ö† Uncraftable: " .. id)
    return false
  end
  local now = os.clock()
  local since = now - lastCraftTime
  if since < MIN_CRAFT_DELAY then sleep(MIN_CRAFT_DELAY - since) end
  local result = meSafe("craftItem", { name = id, count = count })
  if result then
    lastCraftTime = os.clock()
    craftsThisLoop = craftsThisLoop + 1
    log("üõ† Craft queued: " .. count .. "x " .. id)
    return true
  else
    log("‚ùå craftItem failed for " .. id)
    return false
  end
end

local function exportItem(id, count)
  local ok = meSafe("exportItem", { name = id, count = count }, TARGET_SIDE)
  if ok then
    log("‚úî Exported " .. count .. "x " .. id .. " to " .. TARGET_SIDE)
    return true
  else
    log("‚úñ Export failed for " .. id .. " (" .. count .. ")")
    return false
  end
end

-- Push logic with Netherite filter
local function pushItem(id, quota)
  -- Skip non-Netherite tools
  if id:find("_") and id:find("netherite") == nil and id:find("pickaxe") or id:find("axe") or id:find("shovel") or id:find("hoe") or id:find("sword") then
    if not isNetheriteTool(id) then
      log("‚ö† Skipping non-Netherite tool request: " .. id)
      return
    end
  end

  local available = getItemCount(id)
  if available >= quota then
    exportItem(id, quota)
    return
  end
  local needed = quota - available
  if needed > 0 then
    if requestCraft(id, needed) then
      log("‚è≥ Craft queued to reach quota: " .. needed .. "x " .. id)
    else
      log("‚ö† Could not queue craft for " .. id)
    end
  end
end

-- Safe colony calls
local function safeGetRequests()
  local ok, res = pcall(function() return colony.getRequests() end)
  return ok and res or {}
end

local function safeGetBuilderResources(loc)
  local ok, res = pcall(function() return colony.getBuilderResources(loc) end)
  return ok and res or {}
end

local function safeIsPendingConstruction(loc)
  local ok, res = pcall(function() return colony.isPendingConstruction(loc) end)
  return ok and res or false
end

-- Main loop
while true do
  local ok, err = xpcall(function()
    craftsThisLoop = 0
    local handled = 0
    local seen = {}

    -- Colony-wide requests
    for _, req in ipairs(safeGetRequests()) do
      for _, item in ipairs(req.items or {}) do
        local id = item.name
        if id and not seen[id] then
          local quota = (item.maxCount and item.maxCount == 1) and 4 or 64
          pushItem(id, quota)
          seen[id] = true
          handled = handled + 1
        end
      end
    end

    -- Builder hut-specific requests via manual locations
    for _, loc in ipairs(BUILDERS) do
      if safeIsPendingConstruction(loc) then
        log("Builder at (" .. (loc.x or "?") .. "," .. (loc.y or "?") .. "," .. (loc.z or "?") .. ") has a pending construction job")
        for _, it in ipairs(safeGetBuilderResources(loc)) do
          local id = it.item and it.item.name
          if id and not seen[id] then
            local quota = it.needed or 1
            pushItem(id, quota)
            seen[id] = true
            handled = handled + 1
          end
        end
      else
        log("Builder at (" .. (loc.x or "?") .. "," .. (loc.y or "?") .. "," .. (loc.z or "?") .. ") is idle, skipping")
      end
    end

    log("Loop complete, handled " .. handled .. " unique items")
  end, function(e)
    return debug and debug.traceback and debug.traceback(e) or tostring(e)
  end)

  if not ok then
    log("üî• Top-level loop error recovered:\n" .. tostring(err))
  end

  sleep(5)
end
