--------------------
-- BUILDER HUT AUTOMATION (5-block range from computer)
--------------------
local SCAN_INTERVAL = 10  -- seconds between idle scans
local CHEST_SIDE = "left" -- adjust to where your chest is
local MAX_DISTANCE = 5    -- blocks from computer to consider
local colony_integrator = peripheral.wrap("top")
local me_bridge = peripheral.wrap("bottom")
local DEBUG = true

local function dprint(...)
    if DEBUG then print("[DEBUG]", ...) end
end

-- Get all items from AE2
local function getAEItems()
    if type(me_bridge.listItems) ~= "function" then
        dprint("me_bridge.listItems not available!")
        return {}
    end
    local ok, items = pcall(me_bridge.listItems, me_bridge)
    if not ok then
        dprint("Failed to list AE2 items: ", items)
        return {}
    end
    local aeItems = {}
    for _, i in ipairs(items or {}) do
        aeItems[i.name] = i.count or 0
    end
    return aeItems
end

-- Export a stack to a chest
local function exportToChest(itemName, count)
    if not count or count <= 0 then return 0 end
    local ok, moved = pcall(me_bridge.exportItem, me_bridge, {name=itemName, count=count}, CHEST_SIDE)
    if ok and type(moved) == "number" then
        dprint("Exported "..moved.."x "..itemName.." to chest")
        return moved
    else
        dprint("Failed to export "..itemName.." count "..count)
        return 0
    end
end

-- Filter Builder Hut requests by distance from computer
local function getNearbyBuilderRequests()
    local allRequests = colony_integrator.getRequests() or {}
    local nearbyRequests = {}

    local computerPos = {x=0, y=0, z=0}  -- assume computer is origin

    for _, r in ipairs(allRequests) do
        if r.target and string.find(r.target, "Builder") then
            local bPos = r.buildingPosition or {x=0, y=0, z=0} -- fallback if API doesn't provide
            local dx = bPos.x - computerPos.x
            local dy = bPos.y - computerPos.y
            local dz = bPos.z - computerPos.z
            local dist = math.sqrt(dx*dx + dy*dy + dz*dz)
            if dist <= MAX_DISTANCE then
                table.insert(nearbyRequests, r)
            end
        end
    end

    return nearbyRequests
end

-- Process requests one at a time
local function processRequests()
    local aeItems = getAEItems()
    local requests = getNearbyBuilderRequests()

    if #requests == 0 then
        dprint("No nearby builder requests found.")
        return false
    end

    for _, req in ipairs(requests) do
        local itemName = req.items[1].name
        local needed = req.count
        local available = aeItems[itemName] or 0
        local toExport = math.min(needed, available)
        if toExport > 0 then
            local moved = exportToChest(itemName, toExport)
            dprint(string.format("Request for %d x %s, moved %d", needed, itemName, moved))
        else
            dprint("Item "..itemName.." not available in AE2 storage")
        end
    end
    return true
end

-- Main loop
while true do
    local hasRequests = processRequests()
    if hasRequests then
        sleep(1)  -- quick loop if processing requests
    else
        sleep(SCAN_INTERVAL)  -- wait longer if no requests
    end
end
